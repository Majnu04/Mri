<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>MRI 3D Reconstruction - Medical Imaging Analysis</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: #f8f9fa;
        min-height: 100vh;
        color: #2c3e50;
        line-height: 1.6;
      }
      
      .header {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 20px;
        box-shadow: 0 2px 20px rgba(0,0,0,0.1);
        border-bottom: 3px solid #4CAF50;
      }
      
      .header h1 {
        color: #2c3e50;
        font-size: 2.2em;
        text-align: center;
        margin-bottom: 10px;
        font-weight: 300;
      }
      
      .header .subtitle {
        text-align: center;
        color: #7f8c8d;
        font-size: 1.1em;
        margin-bottom: 20px;
      }
      
      .upload-section {
        background: #ffffff;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        padding: 30px;
        margin: 30px auto;
        max-width: 700px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        text-align: center;
      }
      
      .upload-area {
        border: 2px dashed #007bff;
        border-radius: 8px;
        padding: 40px;
        margin: 20px 0;
        background: #f8f9fa;
        transition: all 0.3s ease;
        cursor: pointer;
      }
      
      .upload-area:hover {
        border-color: #0056b3;
        background: #e9ecef;
      }


        transform: translateY(-2px);
      }
      
      .upload-area.dragover {
        border-color: #27ae60;
        background: #d4edda;
      }
      
      .upload-icon {
        font-size: 3em;
        color: #3498db;
        margin-bottom: 15px;
      }
      
      .file-input {
        display: none;
      }
      
      .upload-button {
        background: #007bff;
        color: white;
        border: none;
        padding: 14px 28px;
        border-radius: 6px;
        font-size: 1.1em;
        cursor: pointer;
        margin: 10px;
        transition: all 0.3s ease;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .upload-button:hover {
        background: #0056b3;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0,123,255,0.3);
      }
      
      .process-button {
        background: #28a745;
        margin-left: 15px;
      }
      
      .process-button:hover {
        background: #218838;
        box-shadow: 0 4px 8px rgba(40,167,69,0.3);
      }
      
      .status-area {
        margin: 20px 0;
        padding: 15px;
        border-radius: 10px;
        font-weight: 500;
        text-align: center;
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .status-processing {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        color: #856404;
      }
      
      .status-success {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
      }
      
      .status-error {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
      }
      
      .main-content {
        display: none;
        animation: fadeIn 0.5s ease-in;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .analysis-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        padding: 30px;
        max-width: 1400px;
        margin: 0 auto;
        background: #f8f9fa;
      }
      
      .panel {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        overflow: hidden;
      }
      
      .panel-header {
        background: linear-gradient(45deg, #34495e, #2c3e50);
        color: white;
        padding: 20px;
        font-size: 1.3em;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      
      .panel-content {
        padding: 20px;
      }
      
      .viewer-3d {
        width: 100%;
        height: 450px;
        border-radius: 10px;
        background: #f8f9fa;
        position: relative;
        overflow: hidden;
      }
      
      .slice-viewer {
        width: 100%;
        height: 450px;
        border-radius: 10px;
        background: #000;
        position: relative;
        overflow: hidden;
      }
      
      .slice-canvas {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      
      .controls-section {
        margin: 20px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 10px;
      }
      
      .controls-title {
        font-weight: 600;
        margin-bottom: 15px;
        color: #2c3e50;
        font-size: 1.1em;
      }
      
      .control-group {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 15px;
      }
      
      .toggle-control {
        display: flex;
        align-items: center;
        gap: 8px;
        background: white;
        padding: 8px 15px;
        border-radius: 20px;
        border: 2px solid #e0e0e0;
        transition: all 0.3s ease;
        cursor: pointer;
        user-select: none;
      }
      
      .toggle-control:hover {
        border-color: #3498db;
        transform: translateY(-1px);
      }
      
      .toggle-control.active {
        background: #3498db;
        color: white;
        border-color: #3498db;
      }
      
      .toggle-control input[type="checkbox"] {
        margin: 0;
        transform: scale(1.2);
      }
      
      .slider-container {
        margin: 20px 0;
      }
      
      .slider-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        font-weight: 500;
      }
      
      .slice-info {
        background: #3498db;
        color: white;
        padding: 5px 15px;
        border-radius: 15px;
        font-size: 0.9em;
      }
      
      .slider {
        width: 100%;
        height: 8px;
        border-radius: 5px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
        transition: all 0.3s ease;
      }
      
      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #3498db;
        cursor: pointer;
        border: 3px solid white;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      }
      
      .slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #3498db;
        cursor: pointer;
        border: 3px solid white;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      }
      
      .download-section {
        text-align: center;
        margin: 20px 0;
      }
      
      .download-button {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 25px;
        font-size: 1em;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      
      .download-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
      }
      
      .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .info-card {
        background: #e8f4fd;
        border: 1px solid #bee5eb;
        border-radius: 10px;
        padding: 15px;
        margin: 15px 0;
        color: #0c5460;
      }
      
      .info-card .icon {
        color: #17a2b8;
        margin-right: 8px;
      }
      
      @media (max-width: 768px) {
        .analysis-container {
          grid-template-columns: 1fr;
          padding: 10px;
        }
        
        .header h1 {
          font-size: 1.8em;
        }
        
        .upload-section {
          margin: 10px;
          padding: 20px;
        }
        
        .control-group {
          flex-direction: column;
        }
      }
      
      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1><i class="fas fa-brain"></i> MRI 3D Reconstruction</h1>
      <div class="subtitle">Advanced Medical Imaging Analysis with Layer-by-Layer Visualization</div>
    </div>

    <div class="upload-section">
      <form id="uploadForm">
        <div class="upload-area" id="uploadArea">
          <div class="upload-icon">
            <i class="fas fa-cloud-upload-alt"></i>
          </div>
          <h3>Upload DICOM Series</h3>
          <p>Drag and drop your ZIP file here or click to browse</p>
          <input type="file" id="dicomZip" name="dicom_zip" accept=".zip" class="file-input" />
          <div id="fileInfo" class="file-info" style="display: none; margin-top: 10px; padding: 10px; background: #f0f8ff; border-radius: 8px; font-size: 14px;">
            <div id="fileName"></div>
            <div id="fileSize"></div>
            <div id="fileSizeWarning" style="color: #d32f2f; display: none;">
              <i class="fas fa-exclamation-triangle"></i> File size exceeds 2GB limit
            </div>
          </div>
          <div style="margin-top: 20px;">
            <button type="button" class="upload-button" onclick="document.getElementById('dicomZip').click()">
              <i class="fas fa-folder-open"></i> Choose ZIP File
            </button>
            <button type="submit" class="upload-button process-button">
              <i class="fas fa-cogs"></i> Process & Analyze
            </button>
          </div>
        </div>
      </form>
      
      <div id="status" class="status-area"></div>
      
      <div class="info-card">
        <i class="fas fa-info-circle icon"></i>
        <strong>Supported Formats:</strong> ZIP files containing:
        <ul style="margin: 10px 0; padding-left: 20px;">
          <li><strong>DICOM files (.dcm)</strong> - Brain MRI series from medical scanners</li>
          <li><strong>MATLAB files (.mat)</strong> - Research datasets with volume/data variables</li>
        </ul>
        Compatible with datasets from ACRIN-FMISO-Brain, brain metastasis collections, and research repositories.
      </div>
    </div>

    <div id="mainContent" class="main-content">
      <div class="analysis-container">
        <!-- Left Panel: 3D Viewer -->
        <div class="panel">
          <div class="panel-header">
            <i class="fas fa-cube"></i>
            3D Volumetric Reconstruction
          </div>
          <div class="panel-content">
            <div class="controls-section">
              <div class="controls-title">3D Visualization Controls</div>
              <div class="control-group">
                <label class="toggle-control">
                  <input type="checkbox" id="showBrain" checked />
                  <i class="fas fa-brain"></i>
                  Brain Tissue
                </label>
                <label class="toggle-control">
                  <input type="checkbox" id="showAnomalies" checked />
                  <i class="fas fa-exclamation-triangle"></i>
                  All Anomalies
                </label>
                <label class="toggle-control">
                  <input type="checkbox" id="showTumors" checked />
                  <i class="fas fa-circle" style="color: #e74c3c;"></i>
                  Tumors
                </label>
                <label class="toggle-control">
                  <input type="checkbox" id="showCysts" checked />
                  <i class="fas fa-circle" style="color: #3498db;"></i>
                  Cysts
                </label>
              </div>
              <div class="download-section">
                <button id="downloadMeshes" class="download-button">
                  <i class="fas fa-download"></i>
                  Download 3D Meshes
                </button>
              </div>
            </div>
            <div id="viewer" class="viewer-3d"></div>
          </div>
        </div>

        <!-- Right Panel: Layer Navigation -->
        <div class="panel">
          <div class="panel-header">
            <i class="fas fa-layer-group"></i>
            Layer-by-Layer Analysis
          </div>
          <div class="panel-content">
            <div class="controls-section">
              <div class="controls-title">Slice Navigation</div>
              <div class="slider-container">
                <div class="slider-label">
                  <span>Brain Layer Navigation</span>
                  <span class="slice-info">
                    <span id="sliceNumber">0</span> / <span id="totalSlices">0</span>
                  </span>
                </div>
                <input type="range" id="sliceSlider" min="0" max="100" value="0" class="slider">
              </div>
              
              <div class="controls-title">Overlay Options</div>
              <div class="control-group">
                <label class="toggle-control">
                  <input type="checkbox" id="showSegmentationOverlay" />
                  <i class="fas fa-layer-group"></i>
                  Segmentation
                </label>
                <label class="toggle-control">
                  <input type="checkbox" id="showTumorOverlay" />
                  <i class="fas fa-crosshairs" style="color: #e74c3c;"></i>
                  Tumor Overlay
                </label>
                <label class="toggle-control">
                  <input type="checkbox" id="showCystOverlay" />
                  <i class="fas fa-crosshairs" style="color: #3498db;"></i>
                  Cyst Overlay
                </label>
              </div>
            </div>
            <div id="sliceViewer" class="slice-viewer">
              <canvas id="sliceCanvas" class="slice-canvas"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
    <script>
      const form = document.getElementById('uploadForm');
      const status = document.getElementById('status');
      const downloadBtn = document.getElementById('downloadMeshes');
      const mainContent = document.getElementById('mainContent');
      const sliceSlider = document.getElementById('sliceSlider');
      const sliceNumber = document.getElementById('sliceNumber');
      const totalSlices = document.getElementById('totalSlices');
      const sliceCanvas = document.getElementById('sliceCanvas');
      const ctx = sliceCanvas.getContext('2d');
      const uploadArea = document.getElementById('uploadArea');
      
      let meshesBlobUrl = null;
      let currentSlice = 0;
      let volumeInfo = null;

      // Enhanced drag and drop functionality
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('dragover');
      });

      uploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
      });

      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].name.endsWith('.zip')) {
          document.getElementById('dicomZip').files = files;
          updateFileDisplay(files[0]);
        } else {
          updateStatus('Please drop a ZIP file containing DICOM (.dcm) or MATLAB (.mat) files', 'error');
        }
      });

      // File input change handler
      document.getElementById('dicomZip').addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          updateFileDisplay(e.target.files[0]);
        }
      });

      function updateFileDisplay(file) {
        const uploadIcon = uploadArea.querySelector('.upload-icon');
        const heading = uploadArea.querySelector('h3');
        const description = uploadArea.querySelector('p');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const fileSizeWarning = document.getElementById('fileSizeWarning');
        
        uploadIcon.innerHTML = '<i class="fas fa-file-archive"></i>';
        heading.textContent = 'File Selected';
        description.innerHTML = `<strong>${file.name}</strong><br>Ready to process`;
        uploadArea.style.borderColor = '#27ae60';
        uploadArea.style.background = '#d4edda';
        
        // Display file information
        fileName.innerHTML = `<i class="fas fa-file"></i> <strong>File:</strong> ${file.name}`;
        const sizeInMB = (file.size / (1024 * 1024)).toFixed(1);
        fileSize.innerHTML = `<i class="fas fa-hdd"></i> <strong>Size:</strong> ${sizeInMB} MB`;
        
        // Check file size and show warning if too large
        const maxSize = 2 * 1024 * 1024 * 1024; // 2GB
        if (file.size > maxSize) {
          fileSizeWarning.style.display = 'block';
          uploadArea.style.borderColor = '#e74c3c';
          uploadArea.style.background = '#f8d7da';
        } else {
          fileSizeWarning.style.display = 'none';
        }
        
        fileInfo.style.display = 'block';
      }

      function updateStatus(message, type = '') {
        status.textContent = message;
        status.className = 'status-area';
        if (type) {
          status.classList.add(`status-${type}`);
        }
        
        if (type === 'processing') {
          status.innerHTML = '<div class="loading-spinner"></div>' + message;
        }
      }

      // Enhanced toggle controls
      document.querySelectorAll('.toggle-control').forEach(control => {
        const checkbox = control.querySelector('input[type="checkbox"]');
        
        function updateControlState() {
          if (checkbox.checked) {
            control.classList.add('active');
          } else {
            control.classList.remove('active');
          }
        }
        
        updateControlState();
        
        control.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change'));
          }
          updateControlState();
        });
        
        checkbox.addEventListener('change', updateControlState);
      });

      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const file = document.getElementById('dicomZip').files[0];
        if (!file) {
          updateStatus('Please select a ZIP file containing DICOM (.dcm) or MATLAB (.mat) series', 'error');
          return;
        }
        
        // Check file size on client side (2GB limit)
        const maxSize = 2 * 1024 * 1024 * 1024; // 2GB
        if (file.size > maxSize) {
          updateStatus(`File too large (${(file.size / (1024*1024)).toFixed(1)} MB). Maximum size is 2GB. Please compress your files or reduce the number of slices.`, 'error');
          return;
        }
        
        updateStatus(`Uploading ${(file.size / (1024*1024)).toFixed(1)} MB file and processing medical imaging data...`, 'processing');
        const fd = new FormData();
        fd.append('dicom_zip', file);
        
        try {
          const resp = await fetch('/upload', { 
            method: 'POST', 
            body: fd,
            // Add timeout for large files
            signal: AbortSignal.timeout(300000) // 5 minutes
          });
          
          if (!resp.ok) {
            let errorMessage = 'Upload failed';
            try {
              const errorData = await resp.json();
              if (errorData.message) {
                errorMessage = errorData.message;
                if (errorData.suggestions) {
                  errorMessage += '\n\nSuggestions:\n' + errorData.suggestions.map(s => '• ' + s).join('\n');
                }
              }
            } catch {
              const errorText = await resp.text();
              errorMessage = errorText;
            }
            updateStatus('Processing failed: ' + errorMessage, 'error');
            return;
          }
          
          const blob = await resp.blob();
          meshesBlobUrl = URL.createObjectURL(blob);
          downloadBtn.onclick = () => { 
            const a = document.createElement('a'); 
            a.href = meshesBlobUrl; 
            a.download = 'meshes.zip'; 
            a.click(); 
          };
          
          updateStatus('Processing complete. Loading visualization...', 'success');
          
          // Get volume info
          const infoResp = await fetch('/volume_info');
          volumeInfo = await infoResp.json();
          
          if (volumeInfo.loaded) {
            setupSliceNavigation();
            await loadAndRenderMeshesFromZip(await blob.arrayBuffer());
            mainContent.style.display = 'block';
            updateStatus('Analysis complete! Explore your MRI data using the controls below.', 'success');
          }
        } catch (error) {
          updateStatus('Error: ' + error.message, 'error');
        }
      });

      function setupSliceNavigation() {
        if (!volumeInfo) return;
        
        sliceSlider.max = volumeInfo.total_slices - 1;
        sliceSlider.value = Math.floor(volumeInfo.total_slices / 2);
        totalSlices.textContent = volumeInfo.total_slices;
        
        sliceSlider.addEventListener('input', (e) => {
          currentSlice = parseInt(e.target.value);
          sliceNumber.textContent = currentSlice;
          loadSlice(currentSlice);
        });
        
        // Load initial slice
        currentSlice = parseInt(sliceSlider.value);
        sliceNumber.textContent = currentSlice;
        loadSlice(currentSlice);
        
        // Setup overlay controls
        document.getElementById('showSegmentationOverlay').addEventListener('change', () => loadSlice(currentSlice));
        document.getElementById('showTumorOverlay').addEventListener('change', () => loadSlice(currentSlice));
        document.getElementById('showCystOverlay').addEventListener('change', () => loadSlice(currentSlice));
      }

      async function loadSlice(sliceNum) {
        try {
          const resp = await fetch(`/slice/${sliceNum}`);
          const data = await resp.json();
          
          if (data.error) {
            console.error('Slice error:', data.error);
            return;
          }
          
          // Setup canvas
          const container = document.getElementById('sliceViewer');
          sliceCanvas.width = container.clientWidth;
          sliceCanvas.height = container.clientHeight;
          
          // Load and draw base slice
          const img = new Image();
          img.onload = () => {
            ctx.clearRect(0, 0, sliceCanvas.width, sliceCanvas.height);
            
            // Calculate scaling to fit canvas
            const scale = Math.min(sliceCanvas.width / img.width, sliceCanvas.height / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const x = (sliceCanvas.width - scaledWidth) / 2;
            const y = (sliceCanvas.height - scaledHeight) / 2;
            
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Draw overlays
            drawOverlays(data.overlays, x, y, scaledWidth, scaledHeight);
          };
          img.src = 'data:image/png;base64,' + data.slice;
          
        } catch (error) {
          console.error('Error loading slice:', error);
        }
      }

      function drawOverlays(overlays, x, y, width, height) {
        if (document.getElementById('showSegmentationOverlay').checked && overlays.segmentation) {
          drawOverlay(overlays.segmentation, x, y, width, height, 'rgba(255, 255, 0, 0.3)');
        }
        if (document.getElementById('showTumorOverlay').checked && overlays.tumor) {
          drawOverlay(overlays.tumor, x, y, width, height, 'rgba(255, 0, 0, 0.5)');
        }
        if (document.getElementById('showCystOverlay').checked && overlays.cyst) {
          drawOverlay(overlays.cyst, x, y, width, height, 'rgba(0, 0, 255, 0.5)');
        }
      }

      function drawOverlay(overlayData, x, y, width, height, color) {
        const overlayImg = new Image();
        overlayImg.onload = () => {
          ctx.save();
          ctx.globalCompositeOperation = 'source-over';
          ctx.fillStyle = color;
          
          // Create a temporary canvas for the overlay
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = overlayImg.width;
          tempCanvas.height = overlayImg.height;
          
          tempCtx.drawImage(overlayImg, 0, 0);
          const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          
          // Create colored overlay
          for (let i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i] > 128) { // If pixel is bright (part of mask)
              const rgb = color.match(/\d+/g);
              imageData.data[i] = parseInt(rgb[0]);     // R
              imageData.data[i + 1] = parseInt(rgb[1]); // G
              imageData.data[i + 2] = parseInt(rgb[2]); // B
              imageData.data[i + 3] = parseInt(rgb[3] * 255); // A
            } else {
              imageData.data[i + 3] = 0; // Transparent
            }
          }
          
          tempCtx.putImageData(imageData, 0, 0);
          ctx.drawImage(tempCanvas, x, y, width, height);
          ctx.restore();
        };
        overlayImg.src = 'data:image/png;base64,' + overlayData;
      }

      async function loadAndRenderMeshesFromZip(arrayBuffer) {
        try {
          const zip = await JSZip.loadAsync(arrayBuffer);
          
          const brainFile = zip.file('brain.obj');
          const anomaliesFile = zip.file('anomalies.obj');
          const tumorsFile = zip.file('tumors.obj');
          const cystsFile = zip.file('cysts.obj');
          
          if (!brainFile) { 
            updateStatus('brain.obj missing in zip', 'error'); 
            return; 
          }
          
          const brainText = await brainFile.async('text');
          const anomaliesText = anomaliesFile ? await anomaliesFile.async('text') : null;
          const tumorsText = tumorsFile ? await tumorsFile.async('text') : null;
          const cystsText = cystsFile ? await cystsFile.async('text') : null;
        
        initThree(brainText, anomaliesText, tumorsText, cystsText);
        } catch (error) {
          console.error('Error loading meshes from zip:', error);
          updateStatus('Error loading 3D models: ' + error.message, 'error');
        }
      }

      // Three.js scene
      let scene, camera, renderer;
      function initThree(brainOBJText, anomaliesOBJText, tumorsOBJText, cystsOBJText) {
        const container = document.getElementById('viewer');
        container.innerHTML = '';
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 0, 150);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);
        
        // Enhanced lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(-10, -10, -5);
        scene.add(pointLight);

        // Check if OBJLoader is available
        if (typeof THREE.OBJLoader === 'undefined') {
          updateStatus('OBJLoader not loaded. Please refresh the page.', 'error');
          return;
        }
        
        const loader = new THREE.OBJLoader();
        
        // Load brain with enhanced material
        const brain = loader.parse(brainOBJText);
        brain.traverse((c) => { 
          if (c.isMesh) { 
            c.material = new THREE.MeshPhongMaterial({ 
              color: 0xcccccc, 
              opacity: 0.7, 
              transparent: true,
              shininess: 30
            }); 
            c.castShadow = true;
            c.receiveShadow = true;
          } 
        });
        brain.name = 'brain';
        scene.add(brain);

        // Load anomalies (general)
        if (anomaliesOBJText) {
          const anomalies = loader.parse(anomaliesOBJText);
          anomalies.traverse((c) => { 
            if (c.isMesh) { 
              c.material = new THREE.MeshPhongMaterial({ 
                color: 0xff6600,
                shininess: 50
              }); 
              c.castShadow = true;
            } 
          });
          anomalies.name = 'anomalies';
          scene.add(anomalies);
        }

        // Load tumors (specific)
        if (tumorsOBJText) {
          const tumors = loader.parse(tumorsOBJText);
          tumors.traverse((c) => { 
            if (c.isMesh) { 
              c.material = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                shininess: 50
              }); 
              c.castShadow = true;
            } 
          });
          tumors.name = 'tumors';
          scene.add(tumors);
        }

        // Load cysts (specific)
        if (cystsOBJText) {
          const cysts = loader.parse(cystsOBJText);
          cysts.traverse((c) => { 
            if (c.isMesh) { 
              c.material = new THREE.MeshPhongMaterial({ 
                color: 0x0066ff,
                shininess: 50
              }); 
              c.castShadow = true;
            } 
          });
          cysts.name = 'cysts';
          scene.add(cysts);
        }

        // Enhanced animation
        let mouseX = 0, mouseY = 0;
        const windowHalfX = container.clientWidth / 2;
        const windowHalfY = container.clientHeight / 2;

        container.addEventListener('mousemove', (event) => {
          mouseX = (event.clientX - windowHalfX) / windowHalfX;
          mouseY = (event.clientY - windowHalfY) / windowHalfY;
        });

        const animate = function () {
          requestAnimationFrame(animate);
          
          // Smooth rotation based on mouse position
          scene.rotation.y += (mouseX * 0.01 - scene.rotation.y) * 0.05;
          scene.rotation.x += (-mouseY * 0.01 - scene.rotation.x) * 0.05;
          
          // Gentle automatic rotation
          scene.rotation.y += 0.002;
          
          renderer.render(scene, camera);
        };
        animate();

        // Setup enhanced controls with visual feedback
        setupEnhancedControls();
      }

      function setupEnhancedControls() {
        document.getElementById('showBrain').addEventListener('change', (e) => {
          const b = scene.getObjectByName('brain'); 
          if (b) b.visible = e.target.checked;
        });
        
        document.getElementById('showAnomalies').addEventListener('change', (e) => {
          const a = scene.getObjectByName('anomalies'); 
          if (a) a.visible = e.target.checked;
        });
        
        document.getElementById('showTumors').addEventListener('change', (e) => {
          const t = scene.getObjectByName('tumors'); 
          if (t) t.visible = e.target.checked;
        });
        
        document.getElementById('showCysts').addEventListener('change', (e) => {
          const c = scene.getObjectByName('cysts'); 
          if (c) c.visible = e.target.checked;
        });
      }
    </script>
  </body>
</html>