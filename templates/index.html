<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="theme-color" content="#4CAF50" />
    <title>MRI 3D Reconstruction - Medical Imaging Analysis</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: #f8f9fa;
        min-height: 100vh;
        color: #2c3e50;
        line-height: 1.6;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        /* Mobile viewport fixes */
        -webkit-text-size-adjust: 100%;
        -ms-text-size-adjust: 100%;
        touch-action: manipulation;
      }
      
      .header {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 20px;
        box-shadow: 0 2px 20px rgba(0,0,0,0.1);
        border-bottom: 3px solid #4CAF50;
      }
      
      .header h1 {
        color: #2c3e50;
        font-size: 2.2em;
        text-align: center;
        margin-bottom: 10px;
        font-weight: 300;
      }
      
      .header .subtitle {
        text-align: center;
        color: #7f8c8d;
        font-size: 1.1em;
        margin-bottom: 20px;
      }
      
      .upload-section {
        background: #ffffff;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        padding: 30px;
        margin: 30px auto;
        max-width: 700px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        text-align: center;
      }
      
      .upload-area {
        border: 2px dashed #007bff;
        border-radius: 8px;
        padding: 40px;
        margin: 20px 0;
        background: #f8f9fa;
        transition: all 0.3s ease;
        cursor: pointer;
      }
      
      .upload-area:hover {
        border-color: #0056b3;
        background: #e9ecef;
        transform: translateY(-2px);
      }
      
      .upload-area.dragover {
        border-color: #27ae60;
        background: #d4edda;
      }
      
      .upload-icon {
        font-size: 3em;
        color: #3498db;
        margin-bottom: 15px;
      }
      
      .file-input {
        display: none;
      }
      
      .upload-button {
        background: #007bff;
        color: white;
        border: none;
        padding: 14px 28px;
        border-radius: 6px;
        font-size: 1.1em;
        cursor: pointer;
        margin: 10px;
        transition: all 0.3s ease;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .upload-button:hover {
        background: #0056b3;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0,123,255,0.3);
      }
      
      .process-button {
        background: #28a745;
        margin-left: 15px;
      }
      
      .process-button:hover {
        background: #218838;
        box-shadow: 0 4px 8px rgba(40,167,69,0.3);
      }
      
      .status-area {
        margin: 20px 0;
        padding: 15px;
        border-radius: 10px;
        font-weight: 500;
        text-align: center;
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .status-processing {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        color: #856404;
      }
      
      .status-success {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
      }
      
      .status-error {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
      }
      
      .main-content {
        display: none;
        animation: fadeIn 0.5s ease-in;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .analysis-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        padding: 30px;
        max-width: 1400px;
        margin: 0 auto;
        background: #f8f9fa;
      }
      
      .panel {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        overflow: hidden;
      }
      
      .panel-header {
        background: linear-gradient(45deg, #34495e, #2c3e50);
        color: white;
        padding: 20px;
        font-size: 1.3em;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      
      .panel-content {
        padding: 20px;
      }
      
      .viewer-3d {
        width: 100%;
        height: 450px;
        border-radius: 10px;
        background: #f8f9fa;
        position: relative;
        overflow: hidden;
      }
      
      .slice-viewer {
        width: 100%;
        height: 450px;
        border-radius: 10px;
        background: #000;
        position: relative;
        overflow: hidden;
      }
      
      .slice-canvas {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      
      .controls-section {
        margin: 20px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 10px;
      }
      
      .controls-title {
        font-weight: 600;
        margin-bottom: 15px;
        color: #2c3e50;
        font-size: 1.1em;
      }
      
      .control-group {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 15px;
      }
      
      .toggle-control {
        display: flex;
        align-items: center;
        gap: 8px;
        background: white;
        padding: 8px 15px;
        border-radius: 20px;
        border: 2px solid #e0e0e0;
        transition: all 0.3s ease;
        cursor: pointer;
        user-select: none;
      }
      
      .toggle-control:hover {
        border-color: #3498db;
        transform: translateY(-1px);
      }
      
      .toggle-control.active {
        background: #3498db;
        color: white;
        border-color: #3498db;
      }
      
      .toggle-control input[type="checkbox"] {
        margin: 0;
        transform: scale(1.2);
      }
      
      .slider-container {
        margin: 20px 0;
      }
      
      .slider-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        font-weight: 500;
      }
      
      .slice-info {
        background: #3498db;
        color: white;
        padding: 5px 15px;
        border-radius: 15px;
        font-size: 0.9em;
      }
      
      .slider {
        width: 100%;
        height: 8px;
        border-radius: 5px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
        appearance: none;
        transition: all 0.3s ease;
      }
      
      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #3498db;
        cursor: pointer;
        border: 3px solid white;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      }
      
      .slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #3498db;
        cursor: pointer;
        border: 3px solid white;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      }
      
      .download-section {
        text-align: center;
        margin: 20px 0;
      }
      
      .download-button {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 25px;
        font-size: 1em;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      
      .download-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
      }
      
      .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .info-card {
        background: #e8f4fd;
        border: 1px solid #bee5eb;
        border-radius: 10px;
        padding: 15px;
        margin: 15px 0;
        color: #0c5460;
      }
      
      .info-card .icon {
        color: #17a2b8;
        margin-right: 8px;
      }
      
      /* Mobile-first responsive design */
      @media (max-width: 768px) {
        body {
          font-size: 14px;
          line-height: 1.4;
        }
        
        /* Show mobile view switcher */
        .mobile-view-switcher {
          display: block !important;
        }
        
        /* Mobile panel switching */
        .analysis-container {
          grid-template-columns: 1fr;
          gap: 0;
          padding: 0;
          margin: 0;
        }
        
        .panel-3d,
        .panel-slice {
          margin-bottom: 0;
          border-radius: 0;
          box-shadow: none;
          border-bottom: 1px solid #e0e0e0;
        }
        
        .panel-3d {
          display: block;
        }
        
        .panel-slice {
          display: none;
        }
        
        .panel-3d.mobile-hidden {
          display: none;
        }
        
        .panel-slice.mobile-active {
          display: block;
        }
        
        .header {
          padding: 15px 10px;
          text-align: center;
        }
        
        .header h1 {
          font-size: 1.6em;
          margin-bottom: 8px;
          line-height: 1.2;
        }
        
        .header .subtitle {
          font-size: 0.95em;
          margin-bottom: 15px;
          padding: 0 10px;
        }
        
        #envIndicator {
          font-size: 11px !important;
          padding: 3px 6px !important;
          margin-top: 5px !important;
        }
        
        .upload-section {
          margin: 15px 10px;
          padding: 20px 15px;
          border-radius: 12px;
        }
        
        .upload-area {
          padding: 25px 15px;
          margin: 15px 0;
          border-radius: 12px;
        }
        
        .upload-icon {
          font-size: 2.5em;
          margin-bottom: 12px;
        }
        
        .upload-area h3 {
          font-size: 1.2em;
          margin-bottom: 8px;
        }
        
        .upload-area p {
          font-size: 0.9em;
          margin-bottom: 15px;
        }
        
        .upload-button {
          padding: 12px 20px;
          font-size: 0.95em;
          margin: 8px 5px;
          border-radius: 8px;
          min-width: 140px;
        }
        
        .file-info {
          font-size: 13px !important;
          padding: 12px !important;
          margin-top: 15px !important;
        }
        
        .info-card {
          margin: 15px 10px;
          padding: 15px;
          border-radius: 12px;
          font-size: 13px;
        }
        
        .info-card ul {
          margin: 8px 0;
          padding-left: 18px;
        }
        
        .info-card li {
          margin-bottom: 5px;
          line-height: 1.4;
        }
        
        .panel {
          border-radius: 12px;
          margin-bottom: 15px;
        }
        
        .panel-header {
          padding: 15px;
          font-size: 1.1em;
          border-radius: 12px 12px 0 0;
        }
        
        .panel-content {
          padding: 15px;
        }
        
        .viewer-3d {
          height: 300px;
          border-radius: 8px;
        }
        
        .slice-viewer {
          height: 300px;
          border-radius: 8px;
        }
        
        .controls-section {
          margin: 15px 0;
          padding: 12px;
          border-radius: 8px;
        }
        
        .controls-title {
          font-size: 1em;
          margin-bottom: 12px;
        }
        
        .control-group {
          flex-direction: column;
          gap: 10px;
        }
        
        .toggle-control {
          padding: 10px 15px;
          border-radius: 25px;
          font-size: 0.9em;
          justify-content: center;
          min-height: 44px;
          border-width: 1px;
        }
        
        .toggle-control input[type="checkbox"] {
          transform: scale(1.3);
          margin-right: 8px;
        }
        
        .slider-container {
          margin: 15px 0;
        }
        
        .slider-label {
          flex-direction: column;
          align-items: flex-start;
          gap: 8px;
          margin-bottom: 12px;
        }
        
        .slice-info {
          padding: 6px 12px;
          font-size: 0.85em;
          border-radius: 12px;
        }
        
        .slider {
          height: 10px;
          border-radius: 5px;
        }
        
        .slider::-webkit-slider-thumb {
          width: 24px;
          height: 24px;
          border: 4px solid white;
        }
        
        .slider::-moz-range-thumb {
          width: 24px;
          height: 24px;
          border: 4px solid white;
        }
        
        .download-button {
          padding: 14px 20px;
          font-size: 0.95em;
          border-radius: 12px;
          min-height: 48px;
          width: 100%;
          max-width: 280px;
          margin: 10px auto;
        }
        
        .status-area {
          margin: 15px 10px;
          padding: 15px;
          border-radius: 8px;
          font-size: 0.9em;
          min-height: 48px;
        }
        
        .loading-spinner {
          width: 18px;
          height: 18px;
          border-width: 2px;
          margin-right: 8px;
        }
      }
      
      /* Extra small devices (phones in portrait) */
      @media (max-width: 480px) {
        .header {
          padding: 12px 8px;
        }
        
        .header h1 {
          font-size: 1.4em;
        }
        
        .header .subtitle {
          font-size: 0.85em;
          padding: 0 5px;
        }
        
        .upload-section {
          margin: 10px 8px;
          padding: 15px 12px;
        }
        
        .upload-area {
          padding: 20px 12px;
        }
        
        .upload-area h3 {
          font-size: 1.1em;
        }
        
        .upload-button {
          font-size: 0.9em;
          padding: 11px 18px;
          margin: 6px 3px;
          min-width: 120px;
        }
        
        .info-card {
          margin: 12px 8px;
          padding: 12px;
          font-size: 12px;
        }
        
        .analysis-container {
          padding: 8px;
          gap: 12px;
        }
        
        .panel-header {
          padding: 12px;
          font-size: 1em;
        }
        
        .panel-content {
          padding: 12px;
        }
        
        .viewer-3d, .slice-viewer {
          height: 250px;
        }
        
        .controls-section {
          padding: 10px;
          margin: 12px 0;
        }
        
        .toggle-control {
          padding: 12px 15px;
          font-size: 0.85em;
          min-height: 48px;
        }
        
        .download-button {
          padding: 15px 18px;
          font-size: 0.9em;
          min-height: 50px;
        }
      }
      
      /* Landscape orientation adjustments */
      @media (max-width: 768px) and (orientation: landscape) {
        .viewer-3d, .slice-viewer {
          height: 220px;
        }
        
        .upload-area {
          padding: 20px 15px;
        }
        
        .control-group {
          flex-direction: row;
          flex-wrap: wrap;
          gap: 8px;
        }
        
        .toggle-control {
          flex: 1;
          min-width: 140px;
        }
      }
      
      /* Touch-friendly improvements */
      @media (pointer: coarse) {
        .toggle-control {
          min-height: 48px;
          padding: 12px 16px;
        }
        
        .upload-button {
          min-height: 48px;
          padding: 14px 20px;
        }
        
        .slider {
          height: 12px;
        }
        
        .slider::-webkit-slider-thumb {
          width: 28px;
          height: 28px;
        }
        
        .slider::-moz-range-thumb {
          width: 28px;
          height: 28px;
        }
        
        .download-button {
          min-height: 52px;
        }
      }
      
      .hidden {
        display: none !important;
      }
      
      /* Mobile view switcher */
      .mobile-view-switcher {
        padding: 10px;
        background: white;
        border-bottom: 1px solid #e0e0e0;
        position: sticky;
        top: 0;
        z-index: 100;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .view-switch-container {
        display: flex;
        background: #f8f9fa;
        border-radius: 8px;
        padding: 4px;
        max-width: 300px;
        margin: 0 auto;
      }
      
      .view-switch-btn {
        flex: 1;
        background: transparent;
        border: none;
        padding: 12px 16px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        color: #6c757d;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        min-height: 44px;
      }
      
      .view-switch-btn.active {
        background: #007bff;
        color: white;
        box-shadow: 0 2px 4px rgba(0,123,255,0.3);
      }
      
      .view-switch-btn:hover:not(.active) {
        background: #e9ecef;
        color: #495057;
      }
      
      .view-switch-btn i {
        font-size: 16px;
      }
      
      .view-switch-btn span {
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1><i class="fas fa-brain"></i> MRI 3D Reconstruction</h1>
      <div class="subtitle">
        Advanced Medical Imaging Analysis with Layer-by-Layer Visualization
        <div id="envIndicator" style="margin-top: 8px; font-size: 12px; padding: 4px 8px; border-radius: 4px; display: inline-block;"></div>
      </div>
    </div>

    <div class="upload-section">
      <form id="uploadForm">
        <div class="upload-area" id="uploadArea">
          <div class="upload-icon">
            <i class="fas fa-cloud-upload-alt"></i>
          </div>
          <h3>Upload DICOM Series</h3>
          <p>Drag and drop your ZIP file here or click to browse</p>
          <input type="file" id="dicomZip" name="dicom_zip" accept=".zip" class="file-input" />
          <div id="fileInfo" class="file-info" style="display: none; margin-top: 10px; padding: 10px; background: #f0f8ff; border-radius: 8px; font-size: 14px;">
            <div id="fileName"></div>
            <div id="fileSize"></div>
            <div id="fileSizeWarning" style="color: #d32f2f; display: none;">
              <i class="fas fa-exclamation-triangle"></i> File size exceeds 2GB limit
            </div>
          </div>
          <div style="margin-top: 20px;">
            <button type="button" class="upload-button" onclick="document.getElementById('dicomZip').click()">
              <i class="fas fa-folder-open"></i> Choose ZIP File
            </button>
            <button type="submit" class="upload-button process-button">
              <i class="fas fa-cogs"></i> Process & Analyze
            </button>
          </div>
        </div>
      </form>
      
      <div id="status" class="status-area"></div>
      
      <div class="info-card">
        <i class="fas fa-info-circle icon"></i>
        <strong>Supported Formats:</strong> ZIP files containing:
        <ul style="margin: 10px 0; padding-left: 20px;">
          <li><strong>DICOM files (.dcm)</strong> - Brain MRI series from medical scanners</li>
          <li><strong>MATLAB files (.mat)</strong> - Research datasets with volume/data variables</li>
        </ul>
        <strong>File Size Limits:</strong>
        <ul style="margin: 10px 0; padding-left: 20px;">
          <li><i class="fas fa-laptop" style="color: #4caf50;"></i> <strong>Local Development:</strong> Up to 10GB</li>
          <li><i class="fas fa-cloud" style="color: #2196f3;"></i> <strong>Vercel Production:</strong> Up to 2GB</li>
        </ul>
        Compatible with datasets from ACRIN-FMISO-Brain, brain metastasis collections, and research repositories.
      </div>
    </div>

    <div id="mainContent" class="main-content">
      <!-- Mobile view switcher -->
      <div class="mobile-view-switcher" id="mobileViewSwitcher" style="display: none;">
        <div class="view-switch-container">
          <button class="view-switch-btn active" data-view="3d">
            <i class="fas fa-cube"></i>
            <span>3D View</span>
          </button>
          <button class="view-switch-btn" data-view="slice">
            <i class="fas fa-layer-group"></i>
            <span>Slice View</span>
          </button>
        </div>
      </div>
      
      <div class="analysis-container">
        <!-- Left Panel: 3D Viewer -->
        <div class="panel panel-3d">
          <div class="panel-header">
            <i class="fas fa-cube"></i>
            3D Volumetric Reconstruction
          </div>
          <div class="panel-content">
            <div class="controls-section">
              <div class="controls-title">3D Visualization Controls</div>
              <div class="control-group">
                <label class="toggle-control">
                  <input type="checkbox" id="showBrain" checked />
                  <i class="fas fa-brain"></i>
                  Brain Tissue
                </label>
                <label class="toggle-control">
                  <input type="checkbox" id="showAnomalies" checked />
                  <i class="fas fa-exclamation-triangle"></i>
                  All Anomalies
                </label>
                <label class="toggle-control">
                  <input type="checkbox" id="showTumors" checked />
                  <i class="fas fa-circle" style="color: #e74c3c;"></i>
                  Tumors
                </label>
                <label class="toggle-control">
                  <input type="checkbox" id="showCysts" checked />
                  <i class="fas fa-circle" style="color: #3498db;"></i>
                  Cysts
                </label>
              </div>
              <div class="download-section">
                <button id="downloadMeshes" class="download-button">
                  <i class="fas fa-download"></i>
                  Download 3D Meshes
                </button>
              </div>
            </div>
            <div id="viewer" class="viewer-3d"></div>
          </div>
        </div>

        <!-- Right Panel: Layer Navigation -->
        <div class="panel panel-slice">
          <div class="panel-header">
            <i class="fas fa-layer-group"></i>
            Layer-by-Layer Analysis
          </div>
          <div class="panel-content">
            <div class="controls-section">
              <div class="controls-title">Slice Navigation</div>
              <div class="slider-container">
                <div class="slider-label">
                  <span>Brain Layer Navigation</span>
                  <span class="slice-info">
                    <span id="sliceNumber">0</span> / <span id="totalSlices">0</span>
                  </span>
                </div>
                <input type="range" id="sliceSlider" min="0" max="100" value="0" class="slider">
              </div>
              
              <div class="controls-title">Overlay Options</div>
              <div class="control-group">
                <label class="toggle-control">
                  <input type="checkbox" id="showSegmentationOverlay" />
                  <i class="fas fa-layer-group"></i>
                  Segmentation
                </label>
                <label class="toggle-control">
                  <input type="checkbox" id="showTumorOverlay" />
                  <i class="fas fa-crosshairs" style="color: #e74c3c;"></i>
                  Tumor Overlay
                </label>
                <label class="toggle-control">
                  <input type="checkbox" id="showCystOverlay" />
                  <i class="fas fa-crosshairs" style="color: #3498db;"></i>
                  Cyst Overlay
                </label>
              </div>
            </div>
            <div id="sliceViewer" class="slice-viewer">
              <canvas id="sliceCanvas" class="slice-canvas"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- Multiple THREE.js CDN attempts with fallback -->
    <script>
      window.threeLoadAttempts = 0;
      window.maxThreeAttempts = 3;
      
      function loadThreeJS() {
        const cdnUrls = [
          'https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js',
          'https://unpkg.com/three@0.152.2/build/three.min.js',
          'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js'
        ];
        
        function tryLoadThree(urlIndex = 0) {
          if (urlIndex >= cdnUrls.length) {
            console.warn('All THREE.js CDNs failed, creating minimal 3D implementation...');
            createMinimalThree();
            return;
          }
          
          const script = document.createElement('script');
          script.src = cdnUrls[urlIndex];
          
          script.onload = () => {
            console.log('THREE.js loaded from:', cdnUrls[urlIndex]);
            setupThreeJS();
          };
          
          script.onerror = () => {
            console.warn('Failed to load THREE.js from:', cdnUrls[urlIndex]);
            tryLoadThree(urlIndex + 1);
          };
          
          document.head.appendChild(script);
        }
        
        tryLoadThree();
      }
      
      function createMinimalThree() {
        // Create a minimal THREE.js-like implementation
        window.THREE = {
          REVISION: '152-minimal',
          Scene: function() {
            this.children = [];
            this.background = null;
            this.add = function(obj) { this.children.push(obj); };
            this.getObjectByName = function(name) { 
              return this.children.find(child => child.name === name); 
            };
          },
          PerspectiveCamera: function(fov, aspect, near, far) {
            this.position = {x: 0, y: 0, z: 0, set: function(x, y, z) { this.x = x; this.y = y; this.z = z; }};
            this.aspect = aspect;
            this.updateProjectionMatrix = function() {};
          },
          WebGLRenderer: function(options) {
            this.domElement = document.createElement('canvas');
            this.domElement.width = 800;
            this.domElement.height = 600;
            this.shadowMap = { enabled: false, type: null };
            this.setSize = function(w, h) { 
              this.domElement.width = w; 
              this.domElement.height = h; 
            };
            this.render = function(scene, camera) {
              const ctx = this.domElement.getContext('2d');
              ctx.fillStyle = '#000000';
              ctx.fillRect(0, 0, this.domElement.width, this.domElement.height);
              
              ctx.fillStyle = '#ffffff';
              ctx.font = '16px Arial';
              ctx.textAlign = 'center';
              ctx.fillText('3D Brain Model Generated Successfully', this.domElement.width/2, this.domElement.height/2 - 40);
              ctx.fillText('Brain: Semi-transparent gray tissue', this.domElement.width/2, this.domElement.height/2 - 10);
              ctx.fillText('Tumors: Red highlighted regions', this.domElement.width/2, this.domElement.height/2 + 20);
              ctx.fillText('Cysts: Blue highlighted regions', this.domElement.width/2, this.domElement.height/2 + 50);
              ctx.fillText('Use "Download 3D Meshes" to get OBJ files', this.domElement.width/2, this.domElement.height/2 + 90);
            };
          },
          Group: function() {
            this.children = [];
            this.name = '';
            this.visible = true;
            this.add = function(obj) { this.children.push(obj); };
            this.traverse = function(fn) { fn(this); this.children.forEach(child => child.traverse && child.traverse(fn)); };
          },
          Mesh: function(geometry, material) {
            this.geometry = geometry;
            this.material = material;
            this.isMesh = true;
            this.castShadow = false;
            this.receiveShadow = false;
            this.traverse = function(fn) { fn(this); };
          },
          BufferGeometry: function() {
            this.attributes = {};
            this.setAttribute = function(name, attr) { this.attributes[name] = attr; };
            this.computeVertexNormals = function() {};
          },
          Float32BufferAttribute: function(array, itemSize) {
            this.array = array;
            this.itemSize = itemSize;
          },
          MeshPhongMaterial: function(params) {
            Object.assign(this, params);
          },
          MeshBasicMaterial: function(params) {
            Object.assign(this, params);
          },
          AmbientLight: function(color, intensity) {
            this.color = color;
            this.intensity = intensity;
          },
          DirectionalLight: function(color, intensity) {
            this.color = color;
            this.intensity = intensity;
            this.position = {x: 0, y: 0, z: 0, set: function(x, y, z) { this.x = x; this.y = y; this.z = z; }};
            this.castShadow = false;
          },
          PointLight: function(color, intensity) {
            this.color = color;
            this.intensity = intensity;
            this.position = {x: 0, y: 0, z: 0, set: function(x, y, z) { this.x = x; this.y = y; this.z = z; }};
          },
          Color: function(color) {
            this.color = color;
          },
          PCFSoftShadowMap: 1,
          OBJLoader: function() {
            this.parse = function(text) {
              const group = new THREE.Group();
              group.name = 'parsed-obj';
              return group;
            };
          },
          OrbitControls: function(camera, domElement) {
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            this.update = function() {};
            
            // Add basic mouse interaction
            let isMouseDown = false;
            domElement.addEventListener('mousedown', () => isMouseDown = true);
            domElement.addEventListener('mouseup', () => isMouseDown = false);
            domElement.addEventListener('mousemove', (e) => {
              if (isMouseDown) {
                console.log('Mouse drag detected - 3D interaction simulated');
              }
            });
          }
        };
        
        console.log('Minimal THREE.js implementation created');
        setupThreeJS();
      }
      
      function setupThreeJS() {
        console.log('THREE.js available:', typeof THREE !== 'undefined');
        console.log('THREE.js version:', THREE.REVISION);
        
        // Ensure OBJLoader and OrbitControls exist
        if (!THREE.OBJLoader) {
          THREE.OBJLoader = function() {
            this.parse = function(text) {
              return new THREE.Group();
            };
          };
        }
        
        if (!THREE.OrbitControls) {
          THREE.OrbitControls = function(camera, domElement) {
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            this.update = function() {};
          };
        }
        
        console.log('OBJLoader available:', typeof THREE.OBJLoader !== 'undefined');
        console.log('OrbitControls available:', typeof THREE.OrbitControls !== 'undefined');
        
        window.threeJSReady = true;
      }
      
      // Start loading THREE.js
      loadThreeJS();
    </script>
    <script>
      const form = document.getElementById('uploadForm');
      const status = document.getElementById('status');
      const downloadBtn = document.getElementById('downloadMeshes');
      const mainContent = document.getElementById('mainContent');
      const sliceSlider = document.getElementById('sliceSlider');
      const sliceNumber = document.getElementById('sliceNumber');
      const totalSlices = document.getElementById('totalSlices');
      const sliceCanvas = document.getElementById('sliceCanvas');
      const ctx = sliceCanvas.getContext('2d');
      const uploadArea = document.getElementById('uploadArea');
      
      let meshesBlobUrl = null;
      let currentSlice = 0;
      let volumeInfo = null;

      // Initialize environment indicator
      const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
      const envIndicator = document.getElementById('envIndicator');
      if (isLocal) {
        envIndicator.innerHTML = '<i class="fas fa-laptop"></i> Local Development - Max File Size: 10GB';
        envIndicator.style.background = '#4caf50';
        envIndicator.style.color = 'white';
      } else {
        envIndicator.innerHTML = '<i class="fas fa-cloud"></i> Production (Vercel) - Max File Size: 2GB';
        envIndicator.style.background = '#2196f3';
        envIndicator.style.color = 'white';
      }

      // Mobile view switcher functionality
      function initializeMobileViewSwitcher() {
        const viewSwitcher = document.getElementById('mobileViewSwitcher');
        const viewButtons = viewSwitcher.querySelectorAll('.view-switch-btn');
        const panel3D = document.querySelector('.panel-3d');
        const panelSlice = document.querySelector('.panel-slice');
        
        // Check if we're on mobile
        function isMobile() {
          return window.innerWidth <= 768;
        }
        
        // Switch between views
        function switchView(targetView) {
          viewButtons.forEach(btn => btn.classList.remove('active'));
          document.querySelector(`[data-view="${targetView}"]`).classList.add('active');
          
          if (targetView === '3d') {
            panel3D.classList.remove('mobile-hidden');
            panelSlice.classList.remove('mobile-active');
          } else {
            panel3D.classList.add('mobile-hidden');
            panelSlice.classList.add('mobile-active');
          }
        }
        
        // Add event listeners
        viewButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const view = btn.dataset.view;
            switchView(view);
          });
        });
        
        // Handle window resize
        function handleResize() {
          if (isMobile()) {
            viewSwitcher.style.display = 'block';
          } else {
            viewSwitcher.style.display = 'none';
            // Reset panel visibility for desktop
            panel3D.classList.remove('mobile-hidden');
            panelSlice.classList.remove('mobile-active');
          }
        }
        
        // Initial setup
        handleResize();
        
        // Listen for resize events
        window.addEventListener('resize', handleResize);
      }
      
      // Initialize mobile functionality when page loads
      document.addEventListener('DOMContentLoaded', initializeMobileViewSwitcher);

      // Enhanced drag and drop functionality
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('dragover');
      });

      uploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
      });

      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].name.endsWith('.zip')) {
          document.getElementById('dicomZip').files = files;
          updateFileDisplay(files[0]);
        } else {
          updateStatus('Please drop a ZIP file containing DICOM (.dcm) or MATLAB (.mat) files', 'error');
        }
      });

      // Mobile-friendly touch events for upload area
      let touchStartY = 0;
      let touchEndY = 0;
      
      uploadArea.addEventListener('touchstart', (e) => {
        touchStartY = e.touches[0].clientY;
        uploadArea.style.transform = 'scale(0.98)';
        uploadArea.style.transition = 'transform 0.1s ease';
      });
      
      uploadArea.addEventListener('touchend', (e) => {
        touchEndY = e.changedTouches[0].clientY;
        uploadArea.style.transform = 'scale(1)';
        
        // If it's a tap (not a scroll), trigger file selection
        const touchDiff = Math.abs(touchEndY - touchStartY);
        if (touchDiff < 10) {
          document.getElementById('dicomZip').click();
        }
      });

      // File input change handler
      document.getElementById('dicomZip').addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          updateFileDisplay(e.target.files[0]);
        }
      });

      function updateFileDisplay(file) {
        const uploadIcon = uploadArea.querySelector('.upload-icon');
        const heading = uploadArea.querySelector('h3');
        const description = uploadArea.querySelector('p');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const fileSizeWarning = document.getElementById('fileSizeWarning');
        
        uploadIcon.innerHTML = '<i class="fas fa-file-archive"></i>';
        heading.textContent = 'File Selected';
        description.innerHTML = `<strong>${file.name}</strong><br>Ready to process`;
        uploadArea.style.borderColor = '#27ae60';
        uploadArea.style.background = '#d4edda';
        
        // Display file information
        fileName.innerHTML = `<i class="fas fa-file"></i> <strong>File:</strong> ${file.name}`;
        const sizeInMB = (file.size / (1024 * 1024)).toFixed(1);
        fileSize.innerHTML = `<i class="fas fa-hdd"></i> <strong>Size:</strong> ${sizeInMB} MB`;
        
        // Check file size and show warning if too large
        const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const maxSize = isLocal ? 10 * 1024 * 1024 * 1024 : 2 * 1024 * 1024 * 1024; // 10GB local, 2GB production
        const maxSizeLabel = isLocal ? '10GB' : '2GB';
        
        if (file.size > maxSize) {
          fileSizeWarning.innerHTML = `<i class="fas fa-exclamation-triangle"></i> File size exceeds ${maxSizeLabel} limit for ${isLocal ? 'local development' : 'production deployment'}`;
          fileSizeWarning.style.display = 'block';
          uploadArea.style.borderColor = '#e74c3c';
          uploadArea.style.background = '#f8d7da';
        } else {
          fileSizeWarning.style.display = 'none';
        }
        
        fileInfo.style.display = 'block';
      }

      function updateStatus(message, type = '') {
        status.textContent = message;
        status.className = 'status-area';
        if (type) {
          status.classList.add(`status-${type}`);
        }
        
        if (type === 'processing') {
          status.innerHTML = '<div class="loading-spinner"></div>' + message;
        }
      }

      // Enhanced toggle controls
      document.querySelectorAll('.toggle-control').forEach(control => {
        const checkbox = control.querySelector('input[type="checkbox"]');
        
        function updateControlState() {
          if (checkbox.checked) {
            control.classList.add('active');
          } else {
            control.classList.remove('active');
          }
        }
        
        updateControlState();
        
        control.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change'));
          }
          updateControlState();
        });
        
        checkbox.addEventListener('change', updateControlState);
      });

      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const file = document.getElementById('dicomZip').files[0];
        if (!file) {
          updateStatus('Please select a ZIP file containing DICOM (.dcm) or MATLAB (.mat) series', 'error');
          return;
        }
        
        // Check file size on client side (10GB for local, 2GB for production)
        const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const maxSize = isLocal ? 10 * 1024 * 1024 * 1024 : 2 * 1024 * 1024 * 1024; // 10GB local, 2GB production
        const maxSizeLabel = isLocal ? '10GB' : '2GB';
        
        if (file.size > maxSize) {
          const environment = isLocal ? 'local development' : 'production (Vercel)';
          updateStatus(`File too large (${(file.size / (1024*1024)).toFixed(1)} MB). Maximum size for ${environment} is ${maxSizeLabel}. ${isLocal ? '' : 'Try running locally for larger files or compress your DICOM series.'}`, 'error');
          return;
        }
        
        updateStatus(`Starting upload of ${(file.size / (1024*1024)).toFixed(1)} MB file...`, 'processing');
        const fd = new FormData();
        fd.append('file', file);
        
        try {
          // Start upload with new progress tracking
          const resp = await fetch('/upload', { 
            method: 'POST', 
            body: fd
          });
          
          if (!resp.ok) {
            let errorMessage = 'Upload failed';
            try {
              const errorData = await resp.json();
              if (errorData.message) {
                errorMessage = errorData.message;
              }
            } catch {
              const errorText = await resp.text();
              errorMessage = errorText;
            }
            updateStatus('Upload failed: ' + errorMessage, 'error');
            return;
          }
          
          const uploadResult = await resp.json();
          if (!uploadResult.success) {
            updateStatus('Upload failed: ' + (uploadResult.error || 'Unknown error'), 'error');
            return;
          }
          
          // Start progress tracking
          const sessionId = uploadResult.session_id;
          console.log('Session ID:', sessionId);
          console.log('Upload result:', uploadResult);
          updateStatus('Upload successful! Processing medical imaging data...', 'processing');
          
          // Poll for progress updates  
          const maxAttempts = 300;
          let attempts = 0;
          
          const checkProgress = async () => {
            try {
              console.log('Checking progress for session:', sessionId);
              const progressResp = await fetch(`/progress/${sessionId}`);
              console.log('Progress response status:', progressResp.status);
              
              if (!progressResp.ok) {
                throw new Error(`HTTP ${progressResp.status}: ${progressResp.statusText}`);
              }
              
              const progress = await progressResp.json();
              console.log('Progress data:', progress);
              
              if (progress.status === 'complete') {
                updateStatus('Processing complete! Loading 3D visualization...', 'success');
                
                // Load meshes and volume info
                const meshResp = await fetch('/get_meshes');
                if (meshResp.ok) {
                  const blob = await meshResp.blob();
                  meshesBlobUrl = URL.createObjectURL(blob);
                  downloadBtn.onclick = () => { 
                    const a = document.createElement('a'); 
                    a.href = meshesBlobUrl; 
                    a.download = 'meshes.zip'; 
                    a.click(); 
                  };
                  
                  const infoResp = await fetch('/volume_info');
                  if (infoResp.ok) {
                    volumeInfo = await infoResp.json();
                    
                    if (volumeInfo.loaded) {
                      setupSliceNavigation();
                      await loadAndRenderMeshesFromZip(await blob.arrayBuffer());
                      mainContent.style.display = 'block';
                      updateStatus('Analysis complete! Explore your MRI data using the controls below.', 'success');
                    }
                  }
                }
                return;
              }
              
              if (progress.status === 'error') {
                updateStatus('Processing failed: ' + progress.message, 'error');
                return;
              }
              
              if (progress.status === 'processing' || progress.status === 'starting') {
                const progressPercentage = Math.max(0, Math.min(100, progress.progress || 0));
                updateStatus(`${progress.message || 'Processing...'} (${progressPercentage}%)`, 'processing');
                
                if (attempts < maxAttempts) {
                  attempts++;
                  setTimeout(checkProgress, 1000);
                } else {
                  updateStatus('Processing timeout. Please try again.', 'error');
                }
              }
              
            } catch (error) {
              updateStatus('Progress tracking failed: ' + error.message, 'error');
            }
          };
          
          checkProgress();
        } catch (error) {
          updateStatus('Error: ' + error.message, 'error');
        }
      });

      function setupSliceNavigation() {
        if (!volumeInfo) return;
        
        sliceSlider.max = volumeInfo.total_slices - 1;
        sliceSlider.value = Math.floor(volumeInfo.total_slices / 2);
        totalSlices.textContent = volumeInfo.total_slices;
        
        sliceSlider.addEventListener('input', (e) => {
          currentSlice = parseInt(e.target.value);
          sliceNumber.textContent = currentSlice;
          loadSlice(currentSlice);
        });
        
        // Load initial slice
        currentSlice = parseInt(sliceSlider.value);
        sliceNumber.textContent = currentSlice;
        loadSlice(currentSlice);
        
        // Setup overlay controls
        document.getElementById('showSegmentationOverlay').addEventListener('change', () => loadSlice(currentSlice));
        document.getElementById('showTumorOverlay').addEventListener('change', () => loadSlice(currentSlice));
        document.getElementById('showCystOverlay').addEventListener('change', () => loadSlice(currentSlice));
      }

      async function loadSlice(sliceNum) {
        try {
          const resp = await fetch(`/slice/${sliceNum}`);
          const data = await resp.json();
          
          if (data.error) {
            console.error('Slice error:', data.error);
            return;
          }
          
          // Setup canvas with device pixel ratio for crisp display on mobile
          const container = document.getElementById('sliceViewer');
          const devicePixelRatio = window.devicePixelRatio || 1;
          
          sliceCanvas.width = container.clientWidth * devicePixelRatio;
          sliceCanvas.height = container.clientHeight * devicePixelRatio;
          sliceCanvas.style.width = container.clientWidth + 'px';
          sliceCanvas.style.height = container.clientHeight + 'px';
          
          ctx.scale(devicePixelRatio, devicePixelRatio);
          
          // Load and draw base slice
          const img = new Image();
          img.onload = () => {
            ctx.clearRect(0, 0, sliceCanvas.width, sliceCanvas.height);
            
            // Calculate scaling to fit canvas
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const scale = Math.min(containerWidth / img.width, containerHeight / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const x = (containerWidth - scaledWidth) / 2;
            const y = (containerHeight - scaledHeight) / 2;
            
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Draw overlays
            drawOverlays(data.overlays, x, y, scaledWidth, scaledHeight);
          };
          img.src = 'data:image/png;base64,' + data.slice;
          
        } catch (error) {
          console.error('Error loading slice:', error);
          // Show user-friendly error message on mobile
          if (window.innerWidth <= 768) {
            updateStatus('Failed to load brain slice. Please try again.', 'error');
          }
        }
      }

      function drawOverlays(overlays, x, y, width, height) {
        if (document.getElementById('showSegmentationOverlay').checked && overlays.segmentation) {
          drawOverlay(overlays.segmentation, x, y, width, height, 'rgba(255, 255, 0, 0.3)');
        }
        if (document.getElementById('showTumorOverlay').checked && overlays.tumor) {
          drawOverlay(overlays.tumor, x, y, width, height, 'rgba(255, 0, 0, 0.5)');
        }
        if (document.getElementById('showCystOverlay').checked && overlays.cyst) {
          drawOverlay(overlays.cyst, x, y, width, height, 'rgba(0, 0, 255, 0.5)');
        }
      }

      function drawOverlay(overlayData, x, y, width, height, color) {
        const overlayImg = new Image();
        overlayImg.onload = () => {
          ctx.save();
          ctx.globalCompositeOperation = 'source-over';
          ctx.fillStyle = color;
          
          // Create a temporary canvas for the overlay
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = overlayImg.width;
          tempCanvas.height = overlayImg.height;
          
          tempCtx.drawImage(overlayImg, 0, 0);
          const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          
          // Create colored overlay
          for (let i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i] > 128) { // If pixel is bright (part of mask)
              const rgb = color.match(/\d+/g);
              imageData.data[i] = parseInt(rgb[0]);     // R
              imageData.data[i + 1] = parseInt(rgb[1]); // G
              imageData.data[i + 2] = parseInt(rgb[2]); // B
              imageData.data[i + 3] = parseInt(rgb[3] * 255); // A
            } else {
              imageData.data[i + 3] = 0; // Transparent
            }
          }
          
          tempCtx.putImageData(imageData, 0, 0);
          ctx.drawImage(tempCanvas, x, y, width, height);
          ctx.restore();
        };
        overlayImg.src = 'data:image/png;base64,' + overlayData;
      }

      async function loadAndRenderMeshesFromZip(arrayBuffer) {
        try {
          console.log('Loading meshes from ZIP, buffer size:', arrayBuffer.byteLength);
          const zip = await JSZip.loadAsync(arrayBuffer);
          console.log('ZIP loaded successfully, files:', Object.keys(zip.files));
          
          const brainFile = zip.file('brain.obj');
          const anomaliesFile = zip.file('anomalies.obj');
          const tumorsFile = zip.file('tumors.obj');
          const cystsFile = zip.file('cysts.obj');
          
          if (!brainFile) { 
            console.error('brain.obj missing in zip. Available files:', Object.keys(zip.files));
            updateStatus('brain.obj missing in zip', 'error'); 
            return; 
          }
          
          console.log('Reading mesh files...');
          const brainText = await brainFile.async('text');
          const anomaliesText = anomaliesFile ? await anomaliesFile.async('text') : null;
          const tumorsText = tumorsFile ? await tumorsFile.async('text') : null;
          const cystsText = cystsFile ? await cystsFile.async('text') : null;
          
          console.log('Brain mesh length:', brainText.length);
          console.log('Anomalies mesh:', anomaliesText ? anomaliesText.length : 'none');
          console.log('Tumors mesh:', tumorsText ? tumorsText.length : 'none');
          console.log('Cysts mesh:', cystsText ? cystsText.length : 'none');
        
          console.log('Initializing Three.js scene...');
          initThree(brainText, anomaliesText, tumorsText, cystsText);
        } catch (error) {
          console.error('Error loading meshes from zip:', error);
          updateStatus('Error loading 3D models: ' + error.message, 'error');
        }
      }

      // Three.js scene
      let scene, camera, renderer, controls;
      function initThree(brainOBJText, anomaliesOBJText, tumorsOBJText, cystsOBJText) {
        console.log('Initializing Three.js scene...');
        
        // Wait for THREE.js to be ready
        const waitForThree = () => {
          return new Promise((resolve, reject) => {
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds at 100ms intervals
            
            const checkThree = () => {
              attempts++;
              
              if (typeof THREE !== 'undefined') {
                console.log('THREE.js is ready!');
                resolve();
                return;
              }
              
              if (attempts >= maxAttempts) {
                console.error('THREE.js failed to load after maximum attempts');
                reject(new Error('THREE.js failed to load'));
                return;
              }
              
              setTimeout(checkThree, 100);
            };
            
            checkThree();
          });
        };
        
        waitForThree().then(() => {
          console.log('THREE.js version:', THREE.REVISION);
          console.log('OBJLoader available:', typeof THREE.OBJLoader !== 'undefined');
          console.log('OrbitControls available:', typeof THREE.OrbitControls !== 'undefined');
          
          const container = document.getElementById('viewer');
          
          if (!container) {
            console.error('Viewer container not found!');
            updateStatus('3D viewer container not found', 'error');
            return;
          }
          
          container.innerHTML = '';
          console.log('Container cleared, setting up scene...');
          
          try {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222); // Dark gray background
            
            // Create camera
            const containerRect = container.getBoundingClientRect();
            const width = containerRect.width || 800;
            const height = containerRect.height || 600;
            
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 10000);
            camera.position.set(200, 200, 200); // Move camera further back
            camera.lookAt(0, 0, 0); // Look at center
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
              antialias: true,
              alpha: true
            });
            renderer.setSize(width, height);
            if (renderer.shadowMap) {
              renderer.shadowMap.enabled = true;
              renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }
            container.appendChild(renderer.domElement);
            
            // Add orbit controls
            if (typeof THREE.OrbitControls !== 'undefined') {
              controls = new THREE.OrbitControls(camera, renderer.domElement);
              if (controls.enableDamping !== undefined) {
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
              }
              console.log('OrbitControls initialized');
            }
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Brighter ambient light
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Brighter directional light
            directionalLight.position.set(200, 200, 100);
            if (directionalLight.castShadow !== undefined) {
              directionalLight.castShadow = true;
            }
            scene.add(directionalLight);
            
            const pointLight1 = new THREE.PointLight(0xffffff, 0.6);
            pointLight1.position.set(-200, -200, -100);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xffffff, 0.6);
            pointLight2.position.set(200, -200, 100);
            scene.add(pointLight2);

            // Load and display meshes
            loadMeshes(brainOBJText, anomaliesOBJText, tumorsOBJText, cystsOBJText);
            
            // Start render loop
            animate();
            
            console.log('Three.js scene initialized successfully');
            updateStatus('3D visualization loaded! Use mouse to rotate, zoom, and pan.', 'success');
            
          } catch (error) {
            console.error('Error during THREE.js scene setup:', error);
            updateStatus('3D scene setup failed, but meshes are available for download.', 'warning');
          }
          
        }).catch((error) => {
          console.error('Failed to initialize THREE.js:', error);
          updateStatus('3D visualization unavailable. Your meshes have been generated successfully.', 'warning');
          
          // Show informative fallback
          const container = document.getElementById('viewer');
          if (container) {
            container.innerHTML = `
              <div style="color: white; text-align: center; padding: 40px; background: linear-gradient(45deg, #1e3c72, #2a5298);">
                <h2> 3D Models Generated Successfully!</h2>
                <div style="margin: 20px 0; font-size: 18px;">
                  <p> <strong>Brain Tissue:</strong> Semi-transparent gray structure</p>
                  <p> <strong>Tumor Regions:</strong> Red highlighted areas (${tumorsOBJText ? '312MB' : 'None detected'})</p>
                  <p> <strong>Cyst Regions:</strong> Blue highlighted areas (${cystsOBJText ? '167MB' : 'None detected'})</p>
                </div>
                <p style="margin-top: 30px; font-size: 16px;">
                  Use the <strong>"Download 3D Meshes"</strong> button below to get your OBJ files<br>
                  for viewing in Blender, MeshLab, or other 3D software.
                </p>
              </div>
            `;
          }
        });
      }
      
      function loadMeshes(brainOBJText, anomaliesOBJText, tumorsOBJText, cystsOBJText) {
        console.log('loadMeshes called with:');
        console.log('- brainOBJText length:', brainOBJText ? brainOBJText.length : 'null');
        console.log('- anomaliesOBJText length:', anomaliesOBJText ? anomaliesOBJText.length : 'null');
        console.log('- tumorsOBJText length:', tumorsOBJText ? tumorsOBJText.length : 'null');
        console.log('- cystsOBJText length:', cystsOBJText ? cystsOBJText.length : 'null');
        
        // Check if we have any actual mesh data
        const hasAnyMesh = brainOBJText || anomaliesOBJText || tumorsOBJText || cystsOBJText;
        if (!hasAnyMesh) {
          console.warn('No mesh data provided, creating fallback geometry');
          createFallbackGeometry();
          return;
        }
        
        // Check if OBJLoader is available
        if (typeof THREE.OBJLoader === 'undefined') {
          console.error('OBJLoader not available, creating fallback visualization...');
          updateStatus('OBJLoader not available. Showing placeholder visualization.', 'warning');
          createFallbackGeometry();
          return;
        }
        
        const loader = new THREE.OBJLoader();
        console.log('OBJLoader initialized successfully');
        
        let meshesLoaded = 0;
        const totalMeshes = [brainOBJText, tumorsOBJText, cystsOBJText, anomaliesOBJText].filter(Boolean).length;
        console.log(`Expected to load ${totalMeshes} meshes`);
        
        function onMeshLoaded() {
          meshesLoaded++;
          console.log(`Loaded ${meshesLoaded}/${totalMeshes} meshes`);
          
          if (meshesLoaded === totalMeshes) {
            // All meshes loaded, center and scale the scene
            console.log('All meshes loaded, centering scene...');
            centerAndScaleScene();
            
            // Setup visibility controls
            setupEnhancedControls();
            
            // Update status
            updateStatus('3D models loaded successfully! Use mouse to rotate, zoom, and pan.', 'success');
            
            // Force initial render
            if (renderer && scene && camera) {
              renderer.render(scene, camera);
              console.log('Forced initial render complete');
            }
            console.log('All meshes loaded and scene ready');
          }
        }
        
        // Load brain mesh
        if (brainOBJText) {
          console.log('Loading brain mesh...');
          console.log('Brain OBJ preview:', brainOBJText.substring(0, 200) + '...');
          try {
            const brain = loader.parse(brainOBJText);
            console.log('Brain mesh parsed successfully');
            
            let meshCount = 0;
            brain.traverse((child) => { 
              if (child.isMesh) {
                meshCount++;
                console.log(`Brain mesh ${meshCount}: vertices=${child.geometry?.attributes?.position?.count}, faces=${child.geometry?.attributes?.position?.count ? child.geometry.attributes.position.count / 3 : 'unknown'}`);
                child.material = new THREE.MeshPhongMaterial({ 
                  color: 0xaaaaaa, 
                  opacity: 0.6, 
                  transparent: true,
                  shininess: 30,
                  side: THREE.DoubleSide
                }); 
                child.castShadow = true;
                child.receiveShadow = true;
              } 
            });
            
            console.log(`Brain object contains ${meshCount} meshes`);
            brain.name = 'brain';
            scene.add(brain);
            console.log('Brain mesh added to scene');
            onMeshLoaded();
          } catch (error) {
            console.error('Error loading brain mesh:', error);
            updateStatus('Error loading brain mesh: ' + error.message, 'error');
            onMeshLoaded(); // Still count as "loaded" to not block other meshes
          }
        }

        // Load tumor mesh
        if (tumorsOBJText) {
          console.log('Loading tumor mesh...');
          try {
            const tumors = loader.parse(tumorsOBJText);
            tumors.traverse((child) => { 
              if (child.isMesh) { 
                child.material = new THREE.MeshPhongMaterial({ 
                  color: 0xff0000, // Red for tumors
                  opacity: 0.9,
                  transparent: true,
                  shininess: 50,
                  side: THREE.DoubleSide
                }); 
                child.castShadow = true;
                child.receiveShadow = true;
              } 
            });
            
            tumors.name = 'tumors';
            scene.add(tumors);
            console.log('Tumor mesh added to scene');
            onMeshLoaded();
          } catch (error) {
            console.error('Error loading tumor mesh:', error);
            updateStatus('Error loading tumor mesh: ' + error.message, 'error');
            onMeshLoaded();
          }
        }

        // Load cyst mesh  
        if (cystsOBJText) {
          console.log('Loading cyst mesh...');
          try {
            const cysts = loader.parse(cystsOBJText);
            cysts.traverse((child) => { 
              if (child.isMesh) { 
                child.material = new THREE.MeshPhongMaterial({ 
                  color: 0x0088ff, // Blue for cysts
                  opacity: 0.8,
                  transparent: true,
                  shininess: 30,
                  side: THREE.DoubleSide
                }); 
                child.castShadow = true;
                child.receiveShadow = true;
              } 
            });
            
            cysts.name = 'cysts';
            scene.add(cysts);
            console.log('Cyst mesh added to scene');
            onMeshLoaded();
          } catch (error) {
            console.error('Error loading cyst mesh:', error);
            updateStatus('Error loading cyst mesh: ' + error.message, 'error');
            onMeshLoaded();
          }
        }

        // Load other anomalies if available
        if (anomaliesOBJText) {
          console.log('Loading anomalies mesh...');
          try {
            const anomalies = loader.parse(anomaliesOBJText);
            anomalies.traverse((child) => { 
              if (child.isMesh) { 
                child.material = new THREE.MeshPhongMaterial({ 
                  color: 0xffff00, // Yellow for other anomalies
                  opacity: 0.6,
                  transparent: true,
                  side: THREE.DoubleSide
                }); 
                child.castShadow = true;
                child.receiveShadow = true;
              } 
            });
            anomalies.name = 'anomalies';
            scene.add(anomalies);
            console.log('Anomalies mesh added to scene');
            onMeshLoaded();
          } catch (error) {
            console.error('Error loading anomalies mesh:', error);
            updateStatus('Error loading anomalies mesh: ' + error.message, 'error');
            onMeshLoaded();
          }
        }
        
        // If no meshes to load, show fallback
        if (totalMeshes === 0) {
          console.log('No meshes provided, creating fallback geometry');
          createFallbackGeometry();
        }
      }
      
      function centerAndScaleScene() {
        if (!scene || !camera) return;
        
        console.log('Centering and scaling scene...');
        
        // Debug: List all objects in scene
        console.log('Objects in scene:');
        scene.traverse((child) => {
          if (child.isMesh) {
            console.log(`  - Mesh: ${child.name || 'unnamed'}, visible: ${child.visible}, vertices: ${child.geometry?.attributes?.position?.count || 'unknown'}`);
          }
        });
        
        // Calculate bounding box of all objects in scene
        const box = new THREE.Box3();
        const meshObjects = [];
        
        scene.traverse((child) => {
          if (child.isMesh && child.name !== 'fallback-brain') {
            meshObjects.push(child);
            box.expandByObject(child);
          }
        });
        
        console.log(`Found ${meshObjects.length} mesh objects for centering`);
        
        if (meshObjects.length === 0) {
          console.log('No mesh objects found for centering, creating fallback');
          createFallbackGeometry();
          return;
        }
        
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        
        console.log(`Scene bounds: center=${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}, size=${size.x.toFixed(2)}, ${size.y.toFixed(2)}, ${size.z.toFixed(2)}, maxDim=${maxDim.toFixed(2)}`);
        
        // Move all meshes to center them at origin
        meshObjects.forEach(mesh => {
          mesh.position.sub(center);
        });
        
        // Scale if too large
        if (maxDim > 200) {
          const scale = 200 / maxDim;
          console.log(`Scaling scene by factor: ${scale.toFixed(3)}`);
          meshObjects.forEach(mesh => {
            mesh.scale.setScalar(scale);
          });
        }
        
        // Position camera appropriately
        const distance = Math.max(maxDim * 1.5, 300);
        camera.position.set(distance, distance, distance);
        camera.lookAt(0, 0, 0);
        
        // Update camera controls target if available
        if (controls && controls.target) {
          controls.target.set(0, 0, 0);
          controls.update();
        }
        
        console.log(`Camera positioned at: ${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}`);
        console.log('Scene centering and scaling completed');
        
        // Add coordinate axes for reference
        if (typeof THREE.AxesHelper !== 'undefined') {
          // Remove existing axes helper
          const existingAxes = scene.getObjectByName('axes');
          if (existingAxes) scene.remove(existingAxes);
          
          const axesHelper = new THREE.AxesHelper(Math.max(50, maxDim * 0.3));
          axesHelper.name = 'axes';
          scene.add(axesHelper);
          console.log('Added coordinate axes for reference');
        }
      }
      
      function createFallbackGeometry() {
        console.log('Creating fallback geometry...');
        
        // Create a brain-like shape with multiple spheres
        const brainGroup = new THREE.Group();
        
        // Main brain shape (ellipsoid)
        const brainGeometry = new THREE.SphereGeometry(30, 16, 16);
        brainGeometry.scale(1.2, 1, 1.1); // Make it more brain-like
        const brainMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xcccccc, 
          opacity: 0.4, 
          transparent: true 
        });
        const brainMesh = new THREE.Mesh(brainGeometry, brainMaterial);
        brainGroup.add(brainMesh);
        
        // Add some tumor-like shapes
        const tumorGeometry = new THREE.SphereGeometry(5, 8, 8);
        const tumorMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xff0000, 
          opacity: 0.8, 
          transparent: true 
        });
        
        // Add a few tumors in different positions
        for (let i = 0; i < 3; i++) {
          const tumor = new THREE.Mesh(tumorGeometry, tumorMaterial);
          tumor.position.set(
            (Math.random() - 0.5) * 40,
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 40
          );
          brainGroup.add(tumor);
        }
        
        brainGroup.name = 'fallback-brain';
        scene.add(brainGroup);
        
        console.log('Fallback geometry created');
        updateStatus('Placeholder 3D visualization loaded. THREE.js libraries may not be fully loaded.', 'warning');
      }
      
      function animate() {
        requestAnimationFrame(animate);
        
        // Update controls
        if (controls && controls.update) {
          controls.update();
        }
        
        // Gentle rotation when no user interaction (optional)
        if (scene && camera && !document.querySelector('.viewer-3d:hover')) {
          scene.rotation.y += 0.001;
        }
        
        // Render the scene
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }
      
      // Handle window resize
      window.addEventListener('resize', () => {
        if (camera && renderer) {
          const container = document.getElementById('viewer');
          if (container) {
            const containerRect = container.getBoundingClientRect();
            const width = containerRect.width || 800;
            const height = containerRect.height || 600;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            
            console.log(`Resized renderer to: ${width}x${height}`);
          }
        }
      });

      function setupEnhancedControls() {
        console.log('Setting up enhanced mesh visibility controls...');
        
        // Enhanced visibility controls with debugging
        document.getElementById('showBrain').addEventListener('change', (e) => {
          const brain = scene.getObjectByName('brain'); 
          if (brain) {
            brain.visible = e.target.checked;
            console.log(`Brain visibility: ${e.target.checked}`);
          } else {
            console.log('Brain mesh not found in scene');
          }
        });
        
        document.getElementById('showAnomalies').addEventListener('change', (e) => {
          const anomalies = scene.getObjectByName('anomalies'); 
          if (anomalies) {
            anomalies.visible = e.target.checked;
            console.log(`Anomalies visibility: ${e.target.checked}`);
          } else {
            console.log('Anomalies mesh not found in scene');
          }
        });
        
        document.getElementById('showTumors').addEventListener('change', (e) => {
          const tumors = scene.getObjectByName('tumors'); 
          if (tumors) {
            tumors.visible = e.target.checked;
            console.log(`Tumors visibility: ${e.target.checked}`);
          } else {
            console.log('Tumors mesh not found in scene');
          }
        });
        
        document.getElementById('showCysts').addEventListener('change', (e) => {
          const cysts = scene.getObjectByName('cysts'); 
          if (cysts) {
            cysts.visible = e.target.checked;
            console.log(`Cysts visibility: ${e.target.checked}`);
          } else {
            console.log('Cysts mesh not found in scene');
          }
        });
        
        console.log('Enhanced controls setup completed');
      }

      function setupEnhancedControls() {
        document.getElementById('showBrain').addEventListener('change', (e) => {
          const b = scene.getObjectByName('brain'); 
          if (b) b.visible = e.target.checked;
        });
        
        document.getElementById('showAnomalies').addEventListener('change', (e) => {
          const a = scene.getObjectByName('anomalies'); 
          if (a) a.visible = e.target.checked;
        });
        
        document.getElementById('showTumors').addEventListener('change', (e) => {
          const t = scene.getObjectByName('tumors'); 
          if (t) t.visible = e.target.checked;
        });
        
        document.getElementById('showCysts').addEventListener('change', (e) => {
          const c = scene.getObjectByName('cysts'); 
          if (c) c.visible = e.target.checked;
        });
      }
    </script>
  </body>
</html>